<!DOCTYPE html><html lang=en color-mode=user><head><meta charset=UTF-8><meta name=viewport content=width=device-width,initial-scale=1><link rel=icon type=image/svg+xml sizes=any href=ico.svg><title>Scrammbl for JS13K 2024 comp</title><style>:root{--minimum-width:50px;--ratio:1;--gap:1rem;--tile-size:clamp(0.375rem, 2.8098rem + 2.8261vw, 5rem);--tile-border:2px solid white;--head:clamp(1.944rem, 1.771rem + 0.8651vw, 2.4414rem);--font:clamp(1.125rem, 1.0815rem + 0.2174vw, 1.25rem);--timer-color:crimson;font-family:georgia,serif}*{box-sizing:border-box;-moz-user-select:none;-webkit-user-select:none;user-select:none;touch-action:none;touch-action:pinch-zoom}html{--s:35px;--c1:#1c2130;--c2:#2e2e2e;--c:var(--c1) 0 25%,#0000 0;--p:0 0/calc(3 * var(--s)) calc(2 * var(--s));background:conic-gradient(from -45deg at 75% 62.5%,var(--c)) var(--p),conic-gradient(from 135deg at 25% 37.5%,var(--c)) var(--p),repeating-conic-gradient(from 90deg,var(--c),var(--c2) 0 50%) 0 0/var(--s) var(--s)}header{text-align:center;display:grid}h1{padding:.5rem;color:#fff;font-family:georgia,serif;font-weight:600;font-size:var(--head);letter-spacing:3px}::-webkit-scrollbar{width:10px}::-webkit-scrollbar-thumb{background:#000}::-webkit-scroll-track{background-color:grey}board-wrapper{display:grid;gap:var(--gap);grid-template-columns:auto repeat(4,minmax(min(var(--tile-size),100%),100px)) auto;grid-template-rows:repeat(6,minmax(min(var(--tile-size),100%),100px)) auto-fill;grid-template-areas:". a1 a2 a3 a4 ." ". b1 middle middle b4 ." ". c1 middle middle c4 ." ". d1 middle middle d4 ." ". e1 e2 e3 e4 ." ". gdata gdata gdata gdata ." ". foot foot foot foot ."}.example-grid{--gap:6px;--tile-size:40px;display:grid;gap:var(--gap);grid-template-columns:auto repeat(3,var(--tile-size)) auto;grid-template-rows:repeat(3,var(--tile-size)) auto;grid-template-areas:". x1 x2 x3 ." ". . . y3 ." ". st . z3 ."}game-data-wrapper{grid-area:gdata;display:grid;grid-template-columns:1fr 1fr;gap:1rem;padding:1rem;text-align:center;color:#fff;font-size:var(--font);font-weight:600}[data-slot=x1]{grid-area:x1}[data-slot=x2]{grid-area:x2}[data-slot=x3]{grid-area:x3}[data-slot=y3]{grid-area:y3}[data-slot=z3]{grid-area:z3}[data-slot=st]{grid-area:st}[data-slot=a1]{grid-area:a1}[data-slot=a2]{grid-area:a2}[data-slot=a3]{grid-area:a3}[data-slot=a4]{grid-area:a4}[data-slot=b1]{grid-area:b1}[data-slot=b4]{grid-area:b4}[data-slot=c1]{grid-area:c1}[data-slot=c4]{grid-area:c4}[data-slot=d1]{grid-area:d1}[data-slot=d4]{grid-area:d4}[data-slot=e1]{grid-area:e1}[data-slot=e2]{grid-area:e2}[data-slot=e3]{grid-area:e3}[data-slot=e4]{grid-area:e4}middle-area{grid-area:middle;gap:var(--gap);display:grid;grid-template-columns:.4fr 1fr .4fr;grid-template-rows:1fr 1fr 1fr;grid-template-areas:"timer timer timer" ". mid-tile ." "level level level"}middle-tile{grid-area:mid-tile;justify-self:center;align-self:center;width:100%}[popover]{width:min(100%,40ch);height:25dvh;position:fixed;background-color:#000;color:#f5f5f5;border:var(--tile-border);font-size:var(--font);font-weight:600;padding:20px}[popover]:popover-open{display:flex;flex-direction:column;align-items:center;justify-content:center;animation:slideIn .2s ease-in-out forwards}[popover]:popover-open::backdrop{animation:darken .2s ease-in-out forwards}#howToPlay{--font:0.8rem;width:min(100%,60ch);font-weight:400;height:min(100dvh,70ch)}#howToPlay li,#howToPlay p{padding-bottom:10px}@keyframes slideIn{to{transform:translate(0)}}@keyframes darken{to{background:rgba(0,0,0,.6)}}button{background:#4682b4;border:2px solid #fff;color:#fff;cursor:pointer;font-size:var(--font);font-weight:600;padding-block:.5rem;padding-inline:1rem;transition:background .2s ease;-moz-user-select:auto;-webkit-user-select:auto;user-select:auto}button:hover{background:color-mix(in hsl,#4682b4,#000 8%)}.timer{grid-area:timer;align-self:center;text-align:center;font-size:2.2rem;color:var(--timer-color);transition:color .3s ease;line-height:1;font-family:Phantomsans,sans-serif;font-weight:800;padding:1rem}.level{grid-area:level;text-align:center;color:#fff;font-family:georgia,serif;font-size:var(--font);font-weight:600}.drag,.in{aspect-ratio:var(--ratio);object-fit:contain;display:flex;position:relative;justify-content:center;align-items:center;font-size:2rem;color:#fff;line-height:1;font-family:Phantomsans,sans-serif;font-weight:600;padding:1rem;cursor:pointer;user-select:none;-webkit-user-select:none;background-color:transparent;border:var(--tile-border)}.in{font-size:1.2rem;padding-block:.5rem;padding-inline:1rem}.eg,.move{background-color:gray}[data-tile=empty]{--tile-color:transparent;background-color:var(--tile-color)}.spawn,[data-tile=spawned]{--tile-color:steelblue;background-color:var(--tile-color)}[data-tile=true]{--tile-color:forestgreen;--tile-border:2px solid forestgreen;background-color:var(--tile-color);border:var(--tile-border)}[data-tile=false]{--tile-color:crimson;background-color:var(--tile-color)}[data-moving=true]{cursor:move;background-color:color-mix(in hsl,var(--tile-color),transparent 7%);border:2px solid gold}[data-highlight=true]{background-color:gold}.drag:focus{border:2px solid gold;background-color:orange}.drag:hover{border:2px solid gold}.drag:active{background-color:color-mix(in hsl,var(--tile-color),transparent 7%);border:2px solid gold}.disabled{pointer-events:none}.is-hidden{display:none!important}.is-visable{display:var(--display,block)!important}</style></head><body><header><h1>Scrammble</h1><button type=button class=info id=howTo>&#9432;</button></header><div id=howToPlay popover><h2>How to play</h2><ul><li>Work out the words before the time runs out.</li><li>Drag and drop the blue letter tile into one of the empty grey tiles or a red letter tile.</li><li>The tile will change color to show if you were correct or not.</li><li>You can swap tiles by dragging a tile over another tile.</li><li>Each time you get a tile in the correct spot 13 seconds will be added to the timer.</li></ul><h3>Example</h3><div class=example-grid><div class=eg data-slot=x1><div class=in data-tile=true>P</div></div><div class=eg data-slot=x2><div class=in data-tile=true>I</div></div><div class=eg data-slot=x3><div class=in data-tile=false>E</div></div><div class=eg data-slot=y3><div class=in data-tile=empty>&nbsp;</div></div><div class=eg data-slot=z3><div class=in data-tile=empty>&nbsp;</div></div><div class=eg data-slot=st><div class=in data-tile=spawned>T</div></div></div><p><strong style=color: green;>P</strong> and <strong style=color: green;>I</strong> are in the correct spot. <strong style=color: crimson;>E</strong> is in the wrong spot.</p><button popovertargetaction=hide popovertarget=howToPlay>Close</button></div><div class=board-wrapper><div class=middle-area><div class=timer>13</div><div class=middle-tile class=spawn swap drop move data-slot=tile-spawn><div class=drag data-tile=spawned data-item=tile-s tabindex=0>&nbsp;</div></div><p class=level>Level &nbsp;&nbsp;</p><div class=endgame id=game-over popover><p>Time's up! Game over.</p><button id=resetGame popovertargetaction=hide popovertarget=game-over>Retry</button></div><div class=completed id=game-finished popover><p class=level-complete>Great! You completed level</p><button id=levelUp popovertargetaction=hide popovertarget=game-finished>Next Level</button></div></div><div class=move drop swap data-slot=a1><div class=drag data-tile=empty data-item=tile-a1 tabindex=0>&nbsp;</div></div><div class=move drop swap data-slot=a2><div class=drag data-tile=empty data-item=tile-a2 tabindex=0>&nbsp;</div></div><div class=move drop swap data-slot=a3><div class=drag data-tile=empty data-item=tile-a3 tabindex=0>&nbsp;</div></div><div class=move drop swap data-slot=a4><div class=drag data-tile=empty data-item=tile-a4 tabindex=0>&nbsp;</div></div><div class=move drop swap data-slot=b4><div class=drag data-tile=empty data-item=tile-b4 tabindex=0>&nbsp;</div></div><div class=move drop swap data-slot=c4><div class=drag data-tile=empty data-item=tile-c4 tabindex=0>&nbsp;</div></div><div class=move drop swap data-slot=d4><div class=drag data-tile=empty data-item=tile-d4 tabindex=0>&nbsp;</div></div><div class=move drop swap data-slot=e4><div class=drag data-tile=empty data-item=tile-e4 tabindex=0>&nbsp;</div></div><div class=move drop swap data-slot=b1><div class=drag data-tile=empty data-item=tile-b1 tabindex=0>&nbsp;</div></div><div class=move drop swap data-slot=c1><div class=drag data-tile=empty data-item=tile-c1 tabindex=0>&nbsp;</div></div><div class=move drop swap data-slot=d1><div class=drag data-tile=empty data-item=tile-d1 tabindex=0>&nbsp;</div></div><div class=move drop swap data-slot=e1><div class=drag data-tile=empty data-item=tile-e1 tabindex=0>&nbsp;</div></div><div class=move drop swap data-slot=e2><div class=drag data-tile=empty data-item=tile-e2 tabindex=0>&nbsp;</div></div><div class=move drop swap data-slot=e3><div class=drag data-tile=empty data-item=tile-e3 tabindex=0>&nbsp;</div></div><div class=game-data-wrapper><span>Moves: 0</span> <span>Best time: -</span> <span>PB: -</span> <span>Streak: 0</span></div></div><footer></footer><script>// Based on XEM's mini drag and drop - https://xem.github.io/miniDragAndDrop/

function createMiniDND() {
    // Initialize the D object with default values
    let D = {
      w: 0, // Flag to indicate dragging state
      g: null, // The element being dragged
      n: null, // The clone of the dragged element
      X: 0, // X position of the pointer
      Y: 0, // Y position of the pointer
      x: 0, // Offset X within the dragged element
      y: 0, // Offset Y within the dragged element
      p: null, // The potential drop target
      f: null, // The final placed element
      o: null, // The original container of the dragged element
      lastHighlight: null, // Last highlighted container
      activeTouchId: null, // Identifier of the active
      droppedHistory: [] // Initialize the dropped history array
    };
  
    function triggerEvent(eventName, data) {
      const event = new CustomEvent(eventName, { detail: { data } });
      document.dispatchEvent(event);
    }
  
    // A utility function to extract important data from an element
    function extractElementData(element) {
      if (!element) return null;
  
      return {
        id: element.id ?? "", // Default to an empty string if id is not present
        classList: Array.from(element.classList ?? []), // Convert classList to an array
        dataset: { ...element.dataset } ?? {} // Copy the dataset object
        // Add any other attributes you want to track
      };
    }
  
    // Validation function to ensure no conflicting classes
    const validateContainerClasses = (container) => {
      const hasCopy = container.classList.contains("copy");
      const hasDelete = container.classList.contains("delete");
      const hasSwap = container.classList.contains("swap");
  
      // Count how many of these classes are present
      const classCount = [hasCopy, hasDelete, hasSwap].filter(Boolean).length;
  
      if (classCount > 1) {
        console.error(
          "Error: A container should not have more than one of .copy, .delete, or .swap classes."
        );
        return false; // Return false if there's an error
      }
  
      return true; // Return true if the validation passes
    };
  
    // Function to handle pointer down events (mouse down or touch start)
    const pointerdown = (e) => {
      // If a touch event is already active, ignore additional touches
      if (D.activeTouchId !== null && e.type.startsWith("touch")) return; // Ignore if there's already an active touch
  
      e.preventDefault(); // Prevent default behavior
  
      D.w = 1; // Set flag to indicate dragging started
      D.g = null; // Initialize grabbed element
      D.n = null; // Initialize the new element
      D.o = null; // Initialize original container
  
      if (e.touches) {
        D.activeTouchId = e.touches[0].identifier;
        // If it's a touch event, get the element under the first touch point
        D.g = document.elementFromPoint(e.touches[0].pageX, e.touches[0].pageY);
        D.activeTouchId = e.touches[0].identifier; // Set the active touch ID for this drag
        // console.log("ActiveTouchDown", D.activeTouchId);
      } else {
        // Otherwise, use the event target
        D.g = e.target;
      }
  
      // Traverse up the DOM tree to find an element with class "drag"
      while (D.g != document && !D.g.classList.contains("drag")) {
        D.g = D.g.parentNode;
      }
  
      if (D.g == document) {
        D.g = null; // No draggable element found
      } else {
        // Store the original container
        D.o = D.g.parentNode;
  
        // Validate container classes before proceeding
        if (!validateContainerClasses(D.o)) {
          return; // Exit the function if validation fails
        }
  
        // Check if parent has "move" or "copy" class
        if (
          D.g.parentNode.classList.contains("move") ||
          D.g.parentNode.classList.contains("copy")
        ) {
          // Get the pointer position
          D.X = e.touches ? e.touches[0].pageX : e.pageX;
          D.Y = e.touches ? e.touches[0].pageY : e.pageY;
          D.x = D.X - e.target.offsetLeft;
          D.y = D.Y - e.target.offsetTop;
  
          // Create a clone of the dragged element
          D.n = document.body.appendChild(D.g.cloneNode(true));
          D.n.setAttribute("data-moving", "true"); // Add data attribute while moving
  
          if (D.g.parentNode.classList.contains("move")) {
            D.g.style.visibility = "hidden"; // Hide the original element if moving
            D.g.m = 1; // Mark as moved
          }
  
          // Set up the clone element's style
          D.n.style.position = "fixed";
          D.n.style.pointerEvents = "none";
          D.n.style.left = D.X - D.x - 8 + "px";
          D.n.style.top = D.Y - D.y - 8 + "px";
        }
      }
    };
  
    // Function to handle pointer move events (mouse move or touch move)
    const pointermove = (e) => {
      e.preventDefault(); // Prevent default behavior
  
      if (D.w && D.n) {
        // Check if the current touch matches the active touch ID
        if (e.touches && D.activeTouchId !== null) {
          const currentTouch = Array.from(e.touches).find(
            (touch) => touch.identifier === D.activeTouchId
          );
          if (!currentTouch) return;
          D.X = currentTouch.pageX;
          D.Y = currentTouch.pageY;
        } else {
          D.X = e.pageX;
          D.Y = e.pageY;
        }
  
        // console.log("ActiveTouchMove", D.activeTouchId);
  
        // Update the position of the new element
        D.n.style.left = D.X - D.x - 8 + "px";
        D.n.style.top = D.Y - D.y - 8 + "px";
  
        // Determine the current drop target
        if (e.touches) {
          D.p = document.elementFromPoint(D.X, D.Y);
        } else {
          D.p = e.target;
        }
  
        // Traverse up to find an element with the drop class
        while (D.p != document && !D.p.classList.contains("drop")) {
          D.p = D.p.parentNode;
        }
  
        // Remove any previous highlights
        if (D.lastHighlight && D.lastHighlight !== D.p) {
          D.lastHighlight.removeAttribute("data-highlight");
        }
  
        if (D.p != document) {
          // If over a valid drop target, highlight it
          D.p.setAttribute("data-highlight", "true");
          D.lastHighlight = D.p; // Remember the last highlighted element
        } else {
          // If not over a valid drop target, highlight the original container
          D.o.setAttribute("data-highlight", "true");
          D.lastHighlight = D.o; // Remember the original container as the last highlight
        }
      }
    };
  
    // Function to handle pointer up events (mouse up or touch end)
    const pointerup = (e) => {
      if (!D.w) return;
  
      e.preventDefault(); // Prevent default behavior
  
      if (e.touches && D.activeTouchId !== null) {
        const currentTouch = Array.from(e.changedTouches).find(
          (touch) => touch.identifier === D.activeTouchId
        );
        if (!currentTouch) return;
      }
  
      // console.log("ActiveTouchUp", D.activeTouchId);
  
      D.w = 0; // Reset dragging flag
      D.activeTouchId = null; // Reset the active touch ID after the drag ends
  
      if (e.touches) {
        D.p = document.elementFromPoint(D.X, D.Y);
      } else {
        D.p = e.target;
      }
  
      if (D.n) {
        // Remove highlight from all containers
        if (D.lastHighlight) {
          D.lastHighlight.removeAttribute("data-highlight");
        }
        // If a new element was created during dragging
        // Traverse up the DOM tree to find an element with class "drop"
        while (D.p != document && !D.p.classList.contains("drop")) {
          D.p = D.p.parentNode;
        }
  
        D.n.removeAttribute("data-moving"); // Remove data attribute after drop and before its cloned
  
        if (D.p != document) {
          // If a valid drop target was found
          if (D.p.classList.contains("delete")) {
            // If the container has the "delete" class
            D.n.remove(); // Always remove the clone
            if (!D.g.parentNode.classList.contains("copy")) {
              D.g.remove(); // Remove the original element if not from a copy container
            }
          } else if (D.p.classList.contains("swap")) {
            // If the container has the "swap" class
            const existingChild = D.p.querySelector(".drag");
            if (existingChild) {
              D.o.appendChild(existingChild); // Move the existing child to the original container
              resetElementStyle(existingChild);
  
              // If the original element was from a copy container, remove it from there
              if (D.g.parentNode.classList.contains("copy")) {
                D.g.remove(); // Remove the original element from the copy container
              }
            }
            D.f = D.p.appendChild(D.n.cloneNode(true));
            resetElementStyle(D.f);
            D.n.remove(); // Remove the clone after appending its clone to the drop target
            if (D.g.m) {
              D.g.remove(); // Remove the original element after a successful swap
            }
          } else {
            D.f = D.p.appendChild(D.n.cloneNode(true));
            resetElementStyle(D.f);
            D.n.remove(); // Remove the clone after appending its clone to the drop target
            if (D.g.m) {
              D.g.remove(); // Remove the original element after a successful drop
            }
          }
        } else {
          // If dropped outside any valid drop container
          D.n.remove(); // Remove the temporary dragging element
          D.g.style.visibility = ""; // Show the original element again
          D.o.appendChild(D.g); // Put it back in its original container
          // Ensure the potential drop target matched the original container when it returns to its original container
          D.p = D.o;
        }
  
        // Create the dropped history event data
        const droppedData = extractElementData(D.n);
        const dropTargetData = extractElementData(D.p);
        const originalContainer = extractElementData(D.o);
  
        D.droppedHistory.push({
          past: originalContainer,
          container: dropTargetData,
          item: droppedData
        });
  
        triggerEvent("dropped", {
          past: originalContainer,
          container: dropTargetData,
          item: droppedData
        });
      }
    };
  
    // Function to reset the style of an element
    const resetElementStyle = (element) => {
      element.style.position = "";
      element.style.pointerEvents = "";
      element.style.left = "";
      element.style.top = "";
    };
  
    // Add event listeners for mouse and touch events
    document.addEventListener("mousedown", pointerdown);
    document.addEventListener("touchstart", pointerdown);
    document.addEventListener("mousemove", pointermove);
    document.addEventListener("touchmove", pointermove, { passive: false });
    document.addEventListener("mouseup", pointerup);
    document.addEventListener("touchend", pointerup);
  
    return {
      onDrop(callback) {
        window.addEventListener("dropped", callback);
      }
    };
  }
  
  //export default createMiniDND;

//import createMiniDND from "./miniDND.js"; Don't need to do this as the gulp task compile the js into one file.

const miniDND = createMiniDND();

// ======================
// GAME DATA
// ======================
// The correct positions of the letters as JSON data
const gameDataArray = {
  level1: [
    {
      index: "0",
      correctPositions: {
        a2: "S",
        a3: "O"
      }
    }
  ],
  level2: [
    {
      index: "0",
      correctPositions: {
        a1: "A",
        a2: "N",
        a3: "T"
      }
    }
  ],
  level3: [
    {
      index: "0",
      correctPositions: {
        a1: "E",
        a2: "C",
        a3: "H",
        a4: "O"
      }
    }
  ],
  level4: [
    {
      index: "0",
      correctPositions: {
        a1: "H",
        a2: "A",
        a3: "N",
        a4: "D",
        b4: "O"
      }
    }
  ],
  level5: [
    {
      index: "0",
      correctPositions: {
        a1: "K",
        a2: "I",
        a3: "W",
        a4: "I",
        b4: "C",
        c4: "E"
      }
    }
  ],
  level6: [
    {
      index: "0",
      correctPositions: {
        a1: "B",
        a2: "O",
        a3: "W",
        a4: "L",
        b4: "I",
        c4: "M",
        d4: "E"
      }
    }
  ],
  level7: [
    {
      index: "0",
      correctPositions: {
        a1: "U",
        a2: "G",
        a3: "L",
        a4: "Y",
        b4: "E",
        c4: "A",
        d4: "R",
        e4: "S"
      }
    }
  ],
  level8: [
    {
      index: "0",
      correctPositions: {
        a1: "D",
        a2: "E",
        a3: "N",
        a4: "T",
        b4: "A",
        c4: "B",
        d4: "O",
        e4: "O",
        b1: "O"
      }
    }
  ],
  level9: [
    {
      index: "0",
      correctPositions: {
        a1: "L",
        a2: "A",
        a3: "V",
        a4: "A",
        b4: "U",
        c4: "D",
        d4: "I",
        e4: "O",
        b1: "E",
        c1: "T"
      }
    }
  ],
  level10: [
    {
      index: "0",
      correctPositions: {
        a1: "A",
        a2: "Q",
        a3: "U",
        a4: "A",
        b4: "G",
        c4: "A",
        d4: "I",
        e4: "N",
        b1: "P",
        c1: "E",
        d1: "X"
      }
    }
  ],
  level11: [
    {
      index: "0",
      correctPositions: {
        a1: "R",
        a2: "A",
        a3: "M",
        a4: "P",
        b4: "A",
        c4: "U",
        d4: "S",
        e4: "E",
        b1: "E",
        c1: "A",
        d1: "C",
        e1: "H"
      }
    }
  ],
  level12: [
    {
      index: "0",
      correctPositions: {
        a1: "F",
        a2: "R",
        a3: "O",
        a4: "G",
        b4: "H",
        c4: "O",
        d4: "S",
        e4: "T",
        b1: "R",
        c1: "O",
        d1: "S",
        e1: "T",
        e2: "O"
      }
    }
  ],
  level13: [
    {
      index: "0",
      correctPositions: {
        a1: "B",
        a2: "R",
        a3: "E",
        a4: "W",
        b4: "H",
        c4: "A",
        d4: "L",
        e4: "E",
        b1: "U",
        c1: "G",
        d1: "G",
        e1: "Y",
        e2: "U",
        e3: "L"
      }
    }
  ]
};


// ======================
// GET GAME DATA
// ======================

let currentLevel = parseInt(window.localStorage.getItem("13kjsgames.frantic13.currentLevel")) || 1;

console.log(currentLevel);

let lastIndex = parseInt(window.localStorage.getItem("13kjsgames.frantic13.lastGameIndex")) || 0;

let hasFailedLastGame = window.localStorage.getItem("13kjsgames.frantic13.hasFailedLastGame") === "true";

function updateLevelDisplay(currentLevel) {
  document.querySelector(".level").textContent = `Level ${currentLevel}`;
}

// Update next game index based on failure or success
function updateNextGameIndex(success) {
  const levelKey = `level${currentLevel}`;
  const levelData = gameDataArray[levelKey];

  if (success) {
    // Move to the next level and reset the index if the level was completed
    currentLevel++;
    window.localStorage.setItem("13kjsgames.frantic13.currentLevel", currentLevel);
    //updateLevelDisplay(currentLevel); // Update the level display
    lastIndex = 0; // Start from the first index for the new level
    window.localStorage.setItem("13kjsgames.frantic13.lastGameIndex", lastIndex);
    window.localStorage.setItem("13kjsgames.frantic13.hasFailedLastGame", false);
  } else {
    // If the player failed, increase the index for the current level
    lastIndex = (lastIndex + 1) % levelData.length;
    window.localStorage.setItem("13kjsgames.frantic13.lastGameIndex", lastIndex);
    window.localStorage.setItem("13kjsgames.frantic13.hasFailedLastGame", true);
  }

  return { currentLevel, lastIndex };
}

function getGameData(level, index) {
  const levelKey = `level${level}`;
  const levelData = gameDataArray[levelKey];

  if (!levelData) {
    console.error(`No data available for level ${level}`);
    return null;
  }

  const gameData = levelData.find((game) => game.index === index.toString());

  if (!gameData) {
    console.error(`No data available for index ${index} in level ${level}`);
    return null;
  }

  return gameData;
}

// Use the correctPositions from the current game data
const currentGameData = getGameData(currentLevel, lastIndex);

let correctPositions = {};

if (!currentGameData) {
  console.error("No game data available.");
  correctPositions = {};
} else {
  // Use the correctPositions from the current game data
  correctPositions = currentGameData.correctPositions;
  hideUnusedSlots(correctPositions);
}

// ========================
// HIDE SLOTS WHEN NOT USED
// ========================

function hideUnusedSlots(correctPositions) {
  const slots = document.querySelectorAll(".move"); // Select all slots

  for (let slot of slots) {
    const slotId = slot.getAttribute("data-slot");

    // Skip the spawn tile slot
    if (slotId === "tile-spawn") {
      continue;
    }

    // If the slot is not in the correctPositions, hide it and set data-tile to "is-hidden"
    if (!correctPositions.hasOwnProperty(slotId)) {
      slot.classList.add("is-hidden");
    } else {
      // Ensure slots that are in correctPositions are visible
      slot.classList.remove("is-hidden");
    }
  }
}

// ======================
// CHECK TILE POSITIONS
// ======================

function checkTiles() {
  const slots = document.querySelectorAll(".move"); // Select all slots and the spawn-tile

  slots.forEach((slot) => {
    const slotId = slot.getAttribute("data-slot");
    const tileDiv = slot.querySelector(".drag");
    const tileValue = tileDiv.textContent.trim(); // Get the value inside the tile

    // Compare with the correct position
    if (correctPositions[slotId] && correctPositions[slotId] === tileValue) {
      tileDiv.setAttribute("data-tile", "true"); // Set to true if correct
      slot.classList.add("disabled"); // Add a disabled class
      slot.classList.remove("move");
      addTime(); // Add 13 seconds
    } else if (slotId === "tile-spawn") {
      tileDiv.setAttribute("data-tile", "spawned"); // Add data-spawned attribute
    } else if (tileValue === "") {
      tileDiv.setAttribute("data-tile", "empty"); // Set to 'empty' if the tile contains no letters
    } else {
      tileDiv.setAttribute("data-tile", "false"); // Set to false if incorrect
      slot.classList.remove("disabled"); // Remove disabled class if incorrect
      slot.classList.add("move");
    }
  });
}

// ======================
// RANDOMISE LETTER SPAWNING
// ======================

// Extract all letters from correctPositions
let letters = Object.values(correctPositions);

// Shuffle the letters array (Fisher-Yates Shuffle)
function shuffle(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
}

// Shuffle the letters to randomize the order
shuffle(letters);

// ======================
// DISPLAY NEXT LETTER IN SPAWN TILE
// ======================

function displayNextLetter() {
  if (letters.length > 0) {
    const nextLetter = letters.shift(); // Get and remove the first letter
    const spawnTile = document.querySelector('[data-slot="tile-spawn"] .drag');

    spawnTile.textContent = nextLetter; // Set the spawn-tile content to the next letter
  }
}

// ======================
// MOVE COUNTER
// ======================

// Initialize the move counter
let moveCount = 0;

//Function to update the move counter
function updateMoveCounter() {
  const moveCounter = document.querySelector(
    "game-data-wrapper span:first-child"
  );
  parseInt(moveCounter.textContent.split(": ")[1]);
  moveCount += 1;
  moveCounter.textContent = `Moves: ${moveCount}`;
  // ===========================
  // END GAME LOGIC
  // ===========================
  if (gameCompleted()) {
    // Define gameCompleted() logic to check if the game is over
    // If game is completed, stop the timer and store game data
    clearInterval(timerInterval); // Stop the timer
    const timeTaken = timeLeft - 13;
    timeLeft = timeTaken; // So the end game timer state does not jump up

    storeGameData(moveCount, timeTaken); // Store the game data with time taken
    calculateStats(); // Optionally calculate average, PB, etc
    updateNextGameIndex(true); // Save to local storage to move to the next level
    const endPopover = document.getElementById("game-finished");
    const finishedLevelText = document.querySelector(".level-complete").textContent = `Great! You completed level ${currentLevel} in ${moveCount} moves and with ${timeTaken} seconds left.`;
    endPopover.showPopover();
    //alert(`Great! You finished in ${moveCount} moves and ${timeTaken} seconds left.`);
  }
}

// ======================
// PAST GAME STATS
// ======================

// Function to calculate and display average moves and personal best (PB)
function calculateStats() {
  const storedData =
    JSON.parse(window.localStorage.getItem("13kjsgames.frantic.personalBests")) || [];

  // Get the personal best moves and best time from local storage
  const personalBestMoves = storedData.bestMoves || Infinity;
  const personalBestTime = storedData.bestTime || -Infinity;

  // Display the personal best moves if available
  if (personalBestMoves !== Infinity) {
    document.querySelector(
      "game-data-wrapper span:nth-child(3)"
    ).textContent = `PB: ${personalBestMoves}`;
  } else {
    document.querySelector(
      "game-data-wrapper span:nth-child(2)"
    ).textContent = `PB: -`;
  }

  // Display the personal best time if available
  if (personalBestTime !== -Infinity) {
    document.querySelector(
      "game-data-wrapper span:nth-child(2)"
    ).textContent = `Best time: ${personalBestTime} secs`;
  } else {
    document.querySelector(
      "game-data-wrapper span:nth-child(2)"
    ).textContent = `Best time: -`;
  }
}

// ======================
// TIMER
// ======================
let timerInterval;
let timeLeft = 13;
let elapsedTime = 0;
let timerStarted = false;
let isPaused = false; // To track the paused state

// Function to update the timer display
function updateTimerDisplay() {
  const timerElement = document.querySelector(".timer");
  timerElement.textContent = timeLeft;
}

function updateTimerColor(timeLeft) {
  const timerElement = document.querySelector(".timer");

  if (timeLeft < 14) {
    timerElement.style.setProperty("--timer-color", "crimson");
  } else if (timeLeft >= 14 && timeLeft <= 45) {
    timerElement.style.setProperty("--timer-color", "gold");
  } else {
    timerElement.style.setProperty("--timer-color", "forestgreen");
  }
}

// Function to start the timer
function startTimer() {
  timerInterval = setInterval(() => {
    timeLeft--;
    updateTimerDisplay();
    updateTimerColor(timeLeft); // Updates the color based on time

    // If time runs out, stop the game
    if (timeLeft <= 0) {
      // ========================
      // GAME OVER / LEVEL FAILED
      // ========================
      clearInterval(timerInterval);
      //alert("Time's up! Game over.");
      updateNextGameIndex(false); // for failure
      const popover = document.getElementById("game-over");
      popover.showPopover();

      // Optionally, you can reset or end the game here

      // ======================
      // MORE RESET GAME LOGIC
      // ======================
      const resetButton = document.getElementById("resetGame");
      if (resetButton) {
        resetButton.addEventListener("click", resetGame);
      }

      // Event to trigger resetGame when the popover is closed when clicking the backdrop
      popover.addEventListener("beforetoggle", (event) => {
        resetGame();
      });
    }
  }, 1000); // Update every second
}

// Function to add time (13 seconds)
function addTime() {
  timeLeft += 13;
  // Make sure the game has not finished
  if (!gameCompleted()) {
    updateTimerDisplay();
  }
}

// Function to pause the timer
function pauseTimer() {
  if (timerInterval) {
    clearInterval(timerInterval); // Stop the interval
    timerInterval = null; // Reset the interval variable
    isPaused = true;
  }
}

// Function to resume the timer
function resumeTimer() {
  if (!timerInterval && isPaused) {
    startTimer(); // Restart the timer if it was paused
    isPaused = false;
  }
}

// ======================
// GAME START
// ======================
function startGame() {
  timeLeft = 13; // Reset to 13 seconds
  clearInterval(timerInterval); // Clear any existing timer
  startTimer(); // Start a new timer
}

// Reset timer (add 13 seconds) when a tile is correctly placed
function resetTimer() {
  timeLeft += 13; // Add 13 seconds
}

// ======================
// RESET GAME
// ======================
/*let initialTileStates = {};

// Function to initialize the state of each tile
window.addEventListener("load",init);function initializeTileStates() {
  document.querySelectorAll(".move").forEach((slot) => {
    const tileDiv = slot.querySelector(".drag");
    const slotId = slot.getAttribute("data-slot");
    initialTileStates[slotId] = {
      content: tileDiv.innerHTML,
      tileData: tileDiv.dataset.tile
    };
  });
}

function updateTilesBasedOnCorrectPositions(correctPositions) {
  const slots = document.querySelectorAll(".move");
  slots.forEach((slot) => {
    const tileDiv = slot.querySelector(".drag");
    const slotId = slot.getAttribute("data-slot");

    // Check and set tile based on correctPositions
    if (!correctPositions[slotId]) {
      tileDiv.innerHTML = correctPositions[slotId];
      //tileDiv.dataset.tile = "correct"; // Or any specific value indicating correct position
    }
  });
} */

function resetGame() {
  console.log("Game reset!");
  location.reload();
  /*
  // Reset the game state (moves, tiles, etc.)
  moveCount = 0; // Reset the move counter
  timeLeft = 13; // Reset the timer back to the initial value
  timerStarted = false;
  clearInterval(timerInterval);

  // Reset the move counter display
  const moveCounter = document.querySelector(
    "game-data-wrapper span:first-child"
  );
  if (moveCounter) {
    moveCounter.textContent = `Moves: ${moveCount}`;
  }

  // Get today's game data and correct positions
  const todayGameData = getTodayGameData();
  if (!todayGameData) {
    console.error("No game data available for today.");
    return;
  }

  const correctPositions = todayGameData.correctPositions;

  initializeTileStates();

  // Display the first letter in the spawn tile
  displayNextLetter();

  updateTimerDisplay(); // Reset the timer display
  updateTimerColor(timeLeft); // Reset the timer color

  // Hide the game over popover if necessary
  const popover = document.getElementById("game-over");
  if (popover) {
    popover.hidePopover(); // Ensure popover is hidden when the game resets
  }*/
}

// ======================
// GAME COMPLETED
// ======================
function gameCompleted() {
  const slots = document.querySelectorAll(".move, .spawn"); // Select only the slots, excluding the spawn tile

  for (let slot of slots) {
    const slotId = slot.getAttribute("data-slot");

    // Skip the spawn tile slot
    if (slotId === "tile-spawn") {
      continue;
    }
    
    // Skip the is-hidden slots
    if (slot.classList.contains("is-hidden")) {
      continue;
    }

    const tileDiv = slot.querySelector(".drag");
    const tileValue = tileDiv ? tileDiv.textContent.trim() : ""; // Get the value inside the tile

    // If any tile is not in the correct position, return false
    if (correctPositions[slotId] && correctPositions[slotId] !== tileValue) {
      return false;
    }

    // If any slot is empty, return false
    if (tileValue === "") {
      return false;
    }
  }

  // If all slots except the spawn tile are correct and not empty, return true
  return true;
}

// ======================
// RESET LEVELS AND INDEX
// ======================

function resetGameProgress() {
  window.localStorage.setItem("13kjsgames.frantic13.currentLevel", 1); // Reset to level 1
  window.localStorage.setItem("13kjsgames.frantic13.lastGameIndex", 0); // Reset index
}

// ======================
// STORE GAME DATA IN LOCAL STORAGE
// ======================

function storeGameData(moveCount, timeTaken) {
  // Retrieve stored data or initialize an object for PB
  const storedData = JSON.parse(
    window.localStorage.getItem("13kjsgames.frantic13.personalBests")
  ) || {
    bestMoves: Infinity, // Use Infinity as the initial value for comparison
    bestTime: Infinity // Use Infinity for best time comparison
  };

  // Check and update the personal best moves
  if (moveCount < storedData.bestMoves) {
    storedData.bestMoves = moveCount;
  }

  // Check and update the personal best time
  if (timeTaken > storedData.bestTime) {
    storedData.bestTime = timeTaken;
  }

  // Store the updated PB in local storage
  window.localStorage.setItem(
    "13kjsgames.frantic13.personalBests",
    JSON.stringify(storedData)
  );
}

// ======================
// ONDROP EVENT LISTENER
// ======================

miniDND.onDrop((event) => {
  const data = event.detail.data;
  //console.log("Dropped:", data);

  // Check if it's the first spawned tile being dropped
  if (!timerStarted && data.past.dataset.slot === "tile-spawn") {
    startTimer(); // Start the timer
    timerStarted = true; // Ensure the timer only starts once
  }

  // Get the event data of the dropped tile
  const swappedSlot = document.querySelector(
    `[data-slot="${data.container.dataset.slot}"]`
  );

  // Check only the swapped tile
  checkTiles(swappedSlot);

  // Update move counter
  const pastSlot = data.past.dataset.slot;
  const currentSlot = data.container.dataset.slot;
  if (pastSlot != currentSlot) {
    updateMoveCounter();
  }

  // Check if the spawn tile has been emptied
  const spawnTileSlot = document.querySelector('[data-slot="tile-spawn"]');
  const spawnTileContent = spawnTileSlot.querySelector(".drag");

  // If the spawn tile is empty, display the next letter
  if (spawnTileContent.textContent.trim() === "") {
    displayNextLetter();
  }
});

// ======================
// DOM LOADS
// ======================
// Initialize when the page loads
document.addEventListener("DOMContentLoaded", () => {
  const currentLevel = parseInt(window.localStorage.getItem("13kjsgames.frantic13.currentLevel")) || 1;
  const howToPlayPopover = document.getElementById("howToPlay");
                                                   // Check if it's level 1
  //if (currentLevel === 1) {
    howToPlayPopover.showPopover();  // Show how to play popover
  //}
  const howToButton = document.getElementById("howTo");
  if (howToButton) {
    howToButton.addEventListener("click", () => {
      howToPlayPopover.showPopover();
    });
  }
  displayNextLetter(); // Show the first letter in the spawn tile on load
  calculateStats(); // Calculate and display stats on page load
  updateLevelDisplay(currentLevel);
});
</script></body></html>